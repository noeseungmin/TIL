## 로그인 처리

### 쿠키 사용
서버에서 로그인에 성공하면 HTTP 응답에 쿠키를 담아서 브라우저에 전달 -> 브라우저는 앞으로 해당 쿠키를 지속해서 보내준다.
쿠키에는 영속쿠키와 세션 쿠키가 있다.
* 영속 쿠키 : 만료 날짜를 입력하면 해당 날짜까지 유지
* 세션 쿠키 : 만료 날짜를 생략하면 브라우저 종료시 까지만 유지

```java
Cookie idCookie = new Cookie("memberId", String.valueOf(loginMember.getId()));
response.addCookie(idCookie);
```
로그인에 성공하면 쿠키를 생성 HttpServlet에 담는다. 쿠키 이름은 memberId이고 값은 회원의 id를 담아 둔다. 웹브라우저 종료전까지 회원의 id를 서버에 계속 보내준다.

```java
@GetMapping("/")
 public String homeLogin(
 @CookieValue(name = "memberId", required = false) Long memberId,
Model model) {
 if (memberId == null) {
 return "home";
 }
 //로그인
 Member loginMember = memberRepository.findById(memberId);
 if (loginMember == null) {
 return "home";
 }
 model.addAttribute("member", loginMember);
 return "loginHome";
 }
 ```
`@CookieValue`를 사용하면 편리하게 쿠키 조회가 가능하다. 로그인 하지 않은 사용자는 홈에 접근 할 수 없게 `required = false`를 사용한다.
* 로그인 쿠키(`memberId`)가 없는 사용자는 기존 home으로 보낸다. 추가로 로그인 쿠키가 있어도 회원이 없을시 home
* 로그인 쿠키(`memberId`)가 있는 사용자는 로그인 사용자 전용 홈 화면인 loginHome 으로 보낸다. 추가로 홈 화면에 화원 관련 정보도 출력해야 해서 member 데이터도 모델에 담아서 전달한다.

```java
@PostMapping("/logout")
public String logout(HttpServletResponse response) {
 expireCookie(response, "memberId");
 return "redirect:/";
}
private void expireCookie(HttpServletResponse response, String cookieName) {
 Cookie cookie = new Cookie(cookieName, null);
 cookie.setMaxAge(0);
 response.addCookie(cookie);
}
```

웹브라우저 종료시 서버에서 해당 쿠키의 종료 날짜를 0으로 지정한다. 로그아웃도 응답 쿠키를 생성하는데 Max-Age=0 를 확인할 수 있다. 해당 쿠키는 즉시 종료된다.

#### 보안 문제
쿠키 값은 임의로 변경할 수 있다.
  * 클라이언트가 쿠키를 강제로 변경하면 다른 사용자가 된다.
  * 실제 웹브라우저 개발자모드 Application Cookie 변경으로 확인
  * Cookie: memberId=1 Cookie: memberId=2 (다른 사용자의 이름이 보임)
쿠키에 보관된 정보는 훔쳐갈 수 있다.
  * 만약 쿠키에 개인정보나, 신용카드 정보가 있다면?
  * 이 정보가 웹 브라우저에도 보관되고, 네트워크 요청마다 계속 클라이언트에서 서버로 전달된다.
  * 쿠키의 정보가 나의 로컬 PC에서 털릴 수도 있고, 네트워크 전송 구간에서 털릴 수도 있다.
해커가 쿠키를 한번 훔쳐가면 평생 사용할 수 있다.
  * 해커가 쿠키를 훔쳐가서 그 쿠키로 악의적인 요청을 계속 시도할 수 있다

쿠키에 중요한 값을 노출하지 않고 사용자 별로 예측 불가능한 임의의 토큰(랜덤 값)을 노출하고, 서버에서 토큰과 사용자 id를 매핑해서 인식한다. 
그리고 서버에서 토큰을 관리해야 하며 토큰이 노출 되더라도 시간이 지나면 사용 불가능 하도록 서버에서 토큰의 만료시간을 짧게 유지 하고 해킹 의심시 해당 토큰을 강제로 제거한다.

### 세션 동작
서버에 중요한 정보를 보관하고 연결을 유지하는 방법을 세션이라 한다.

#### SessionManager
```java
public void createSession(Object value, HttpServletResponse response) {
 //세션 id를 생성하고, 값을 세션에 저장
 String sessionId = UUID.randomUUID().toString();
 sessionStore.put(sessionId, value);
 //쿠키 생성
 Cookie mySessionCookie = new Cookie(SESSION_COOKIE_NAME, sessionId);
 response.addCookie(mySessionCookie);
 }
 
// 세션 조회
 public Object getSession(HttpServletRequest request) {
 Cookie sessionCookie = findCookie(request, SESSION_COOKIE_NAME);
 if (sessionCookie == null) {
 return null;
 }
 return sessionStore.get(sessionCookie.getValue());
 }

//세션 만료
 public void expire(HttpServletRequest request) {
 Cookie sessionCookie = findCookie(request, SESSION_COOKIE_NAME);
 if (sessionCookie != null) {
 sessionStore.remove(sessionCookie.getValue());
 }
 ```
 #### login
 ```java
 private final SessionManager sessionManager;
 //....
sessionManager.createSession(loginMember, response);
 return "redirect:/";
 ```
* 로그인 성공시 세션을 등록하고 세션에 loginMember를 저장해두고 쿠키도 함께 발행한다.

#### logout
```java
@PostMapping("/logout")
public String logoutV2(HttpServletRequest request) {
 sessionManager.expire(request);
 return "redirect:/";
}
```
